

\documentclass[11pt]{article}
\usepackage{fontspec,hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage[BoldFont,SlantFont,CJKchecksingle]{xeCJK}
%载入粗体，斜体，禁止单个汉字一行

%\setCJKmainfont{AR PL KaitiM GB}
\setCJKmainfont{AR PL SungtiL GB} %缺省汉字字体为简体
\setCJKfamilyfont{kai}{AR PL KaitiM GB}
\setCJKfamilyfont{hei}{WenQuanYi Zen Hei}

%\setmainfont{DejaVu Sans Mono:style=Book}
\XeTeXlinebreaklocale "zh"  %断行设置为中文格式
\XeTeXlinebreakskip=0pt plus 1pt minus 0.1pt
\addtolength{\textwidth}{4cm}

%rename abstract to 摘要
\renewcommand{\abstractname}{摘要}
\renewcommand{\contentsname}{目录}


\title{SSL和TSL\\
安全通信协议概要}
\author{\textbf{Simon Horman aka Horms} \\
        \\
\texttt{horms@valinux.co.jp}\\
\texttt{horms@verge.net.au}\\
\texttt{horms@debian.org}}

\date{\today}
%
\begin{document}
\maketitle
%\thispagestyle{plain}
\pagebreak

\begin{abstract}

          SSL/TLS被广泛用于在因特网上安全的传输数据，但是它不是一个具有魔力的
        解决方案，如果没有很好的理解协议是如何工作的和底层的技术，就无法更全面
        的使用SSL/TLS，甚至更糟的是，很容易以不安全的方式使用SSL/TLS。

        这次演示将会解释SSL/TLS是如何工作的，从数据完整性，保密性和端点验证
        这些高层协议的讨论到组成SSL/TLS协议不同报文和最终保护链接安全的加密
        技术这些低层讨论。

        本次面向的观众是对使用或者开发利用SSL/TLS保护数据传输安全应用程序的人。


\end{abstract}

%目录
\tableofcontents

%\setcounter{section}{1}
\section{安全通信}

安全套接字层协议（SSL）和传输层安全协议（TLS）目的是提供一种在网络两端
安全通信的机制，使得两端无需进行端到断的控制，也避免了第三方窃听通信内容。
因特网就是很好的例子。本质上，我们将会谈到连个方面，数据完整性和端点验证。
\\

\subsection{数据完整性}
当两方以安全的模式通信时,重要的是数据要完整地,未加修改的接受,并且没有第三方
探测或者修改通信数据。为了保证数据完整性,SSL/TLS使用了多种加密方法。非对称
加密和对称加密能阻止第三版访问报文内容，即使报文被窃取，从而提供隐私。也能
防止报文被删除或者插入。报文摘要可以防止报文被修改。\\

\subsubsection{非对称加密}
非对称加密，通常也称作公钥加密，允许通信双方进行加密通信，而无需事先商定
密钥。如果加密和揭密使用不同的密钥,那么就称作非对称加密。无可辩驳，最著名的
非对称加密算法就是RSA。\\

RSA 密钥由两个部分组成，公钥和私钥。望文生义，公钥就是任何感兴趣的一方都可以
自由获取的，而私钥是保密的。私钥用来对报文加密，公钥则用来验证。只有私钥的
拥有者可以加密报文，任何可以访问公钥的人都可以验证报文。相反地，公钥可以加密报文，只有私钥可以解密报文。\\

RSA算法的强大之处在于，两个大质数的乘积很难被因式分解。质数越大，密钥越强劲
。质数的长度和产生的密钥导致操作处理非常慢。其他的非对称加密算法都是差不多慢
，所以对于大块的数据传输不适用。因此，SSL/TLS使用非对称加密验证，事先商定对称加密密钥
传输大块数据。在这点上，非对称密钥的优点在于无需再通信之前商定密钥，而且某种
程度上也减轻了非对称加密tigat的慢速。 \\

\subsubsection{对称加密}

对称加密允许双方共享一个密钥来进行加密通信。之所以被成为对称加密，是因为加密
和解密用的是同一个密钥。常见的对称加密算法有DES,DES3和最近的AES。\\

因为加密和解密使用的是同一个密钥，所以双方以安全的方式共享这个密钥就非常重要
。如果第三方获得了密钥，就可以伪造加密报文，也可以解密已加密的报文。如果端点
双方都在同一个私有网络，比如和银行通信的ATM和POS机，这通常不是什么大问题，只
要密钥被事先放在设备里。如果对于更常见的临时通信，正如SSL/TLS提供的，相互
信任关系需要在运行中确定，因此用于对称加密的密钥是哟你非对称通信来获得。对称
加密算法倾向于使用比非对称加密更短的密钥，这通常可以提供相似程度的安全。这
导致再软件中加密算法非常快，这非常重要，因为现在大多数的SSL/TLS都是再软件中
实现的。


\subsubsection{分块}

对称加密算法是基于块的。也就是加密一定量的数据，然后解密。但是SSL/TLS提供基于
流的数据传输，通常数据的数量和加密算法使用的块不想匹配。再任何情况下，传输的
数据和使用的算法是独立的，所以需要分块，把数据分解为块，如果必要的话，填充
块。\\

一个简单的分块实现是仅仅把数据分解为块大小的块，如果必要则填充块，然后加密
得到的块。这种方法叫做{\CJKfamily{kai}{\textbf{电子密码本}（\textbf{ECB})}}模式。
它的最大的缺点就是如果两块文本是相同的，那么密文也将相同。这个信息对于试图
解密流的攻击者是非常有利的。\\

因此，SSL/TLS使用{\CJKfamily{kai}{\textbf{密码分组链接（\textbf{CBC}）}}}模式
。当传送数据流时，第一块文本在加密前和一个\textbf{{\slshape{初始向量}}{（IV）}}异或。再SSL/TLS中，初始向量(IV)再握手商定密钥时产生，并且每次连接都不一
。样。后一块文本和前一块密文再加密前异或。这样第一块后的每一块都依赖于前一块。
所以尽管流里的两块文本相同，密文也不同。\\

\subsubsection{报文验证码}

{\CJKfamily{kai}{\textbf{报文验证码}（\textbf{MAC}）}}保证报文在传送过程中没
有被修改和丢失。它可以被看作是包含密钥的报文摘要。在数据发送时构造，在数据
接收时验证。如果不知道输入文本和密钥，是不可能伪造摘要的，因此，攻击者需要知道密钥
才能为一个改变的报文重新构造一个有效的{\bf{MAC}}。为了防止再次攻击，SSL和TLS
在构造{\bf{MAC}}时包含了单调递增的数字。

\subsection{端点确认}

 在双方通信时，确认对方确实是声称的对方也是非常重要的。在SSL/TLS中，这是通过证书来达到的。
 在建立SSL/TLS连接过程中，一个使用端点证书签字的报文和证书一起发送。证书本身是由认证机构签发的，网络信任是建立在认证机构。\\

 SSL/TLS是客户端-服务器协议。这和高层的客户端-服务器协议比如HTTPS,
 POP3S和IMAPS很类似。这种情况下，典型地是客户端验证确认服务器。也就是，网络服务器
 或者邮件服务器拥有证书，而客户端没有。但是，SSL和TLS允许服务器对客户端进行
 确认，这可以用来控制服务访问。匿名密钥交换也是可以的，在这种情况下，服务器
 不会发送自己的证书。这对攻击这伪造的服务器没有任何安全保证。 \\

 为了验证证书的合法性，需要做多次检查。基本的检查包括证书没有过期，检查它的
 名称和主机名相同。证书也需要加密确认，以确保是由某个认证机构签发的。提供
 认证机构列表来检查是由软件负责的。以HTTPS为例，网页浏览器通常包含了认证机构
 的列表，也可以在安装后添加或删除。服务器使用自己签发的证书也是很常见的，在
 这种情况下，通常由访问该网站的个人来确认证书的合法性。比如，检查离线足迹。
尽管通常希望它是合法的。

\section{版本}

SSL的第一个发布版本是SSLv2,由Netscape发布。但是他有一些缺陷。

\begin{itemize}
 
\item{{\bf{MAC}}比较弱，依赖于{\bf{MD5}}}

\item{验证和加密使用相同的密钥。使得MAC输出密码非常弱}



\end{itemize}


%\section{Socket API}
%
%\lstset{language=C,
%        %bkackgroundcolor=\color{green},
%        numbers=left,
%        breaklines,
%        basicstyle=\ttfamily\small,
%        keywordstyle=\color{red}\ttfamily,
%        identifierstyle=\color{blue}\ttfamily,
%        stringstyle=\ttfamily,
%        commentstyle=\ttfamily,
%        caption=\lstname,
%        captionpos=b}
%
%\lstinputlisting[name=main.cpp,
% %       linerange={28-85},
% %       firstnumber=28,
%        stepnumber=2]{/home/wolf/public/notes/blogs/code/etip/simplec.c} 
%
\end{document}
