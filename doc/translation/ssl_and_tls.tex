

\documentclass[11pt]{article}
\usepackage{fontspec,hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage[BoldFont,SlantFont,CJKchecksingle]{xeCJK}
%载入粗体，斜体，禁止单个汉字一行

%\setCJKmainfont{AR PL KaitiM GB}
\setCJKmainfont{AR PL SungtiL GB} %缺省汉字字体为简体
\setCJKfamilyfont{kai}{AR PL KaitiM GB}
\setCJKfamilyfont{hei}{WenQuanYi Zen Hei}

%\setmainfont{DejaVu Sans Mono:style=Book}
\XeTeXlinebreaklocale "zh"  %断行设置为中文格式
\XeTeXlinebreakskip=0pt plus 1pt minus 0.1pt
\addtolength{\textwidth}{4cm}

%rename abstract to 摘要
\renewcommand{\abstractname}{摘要}
\renewcommand{\contentsname}{目录}


\title{SSL和TSL\\
安全通信协议概要}
\author{\textbf{Simon Horman aka Horms} \\
        \\
\texttt{horms@valinux.co.jp}\\
\texttt{horms@verge.net.au}\\
\texttt{horms@debian.org}}

\date{\today}
%
\begin{document}
\maketitle
%\thispagestyle{plain}
\pagebreak

\begin{abstract}

          SSL/TLS被广泛用于在因特网上安全的传输数据，但是它不是一个具有魔力的
        解决方案，如果没有很好的理解协议是如何工作的和底层的技术，就无法更全面
        的使用SSL/TLS，甚至更糟的是，很容易以不安全的方式使用SSL/TLS。

        这次演示将会解释SSL/TLS是如何工作的，从数据完整性，保密性和端点验证
        这些高层协议的讨论到组成SSL/TLS协议不同报文和最终保护链接安全的加密
        技术这些低层讨论。

        本次面向的观众是对使用或者开发利用SSL/TLS保护数据传输安全应用程序的人。


\end{abstract}

%目录
\tableofcontents

%\setcounter{section}{1}
\section{安全通信}

安全套接字层协议（SSL）和传输层安全协议（TLS）目的是提供一种在网络两端
安全通信的机制，使得两端无需进行端到断的控制，也避免了第三方窃听通信内容。
因特网就是很好的例子。本质上，我们将会谈到连个方面，数据完整性和端点验证。
\\

\subsection{数据完整性}
当两方以安全的模式通信时,重要的是数据要完整地,未加修改的接受,并且没有第三方
探测或者修改通信数据。为了保证数据完整性,SSL/TLS使用了多种加密方法。非对称
加密和对称加密能阻止第三版访问报文内容，即使报文被窃取，从而提供隐私。也能
防止报文被删除或者插入。报文摘要可以防止报文被修改。\\

\subsubsection{非对称加密}
非对称加密，通常也称作公钥加密，允许通信双方进行加密通信，而无需事先商定
密钥。如果加密和揭密使用不同的密钥,那么就称作非对称加密。无可辩驳，最著名的
非对称加密算法就是RSA。\\

RSA 密钥由两个部分组成，公钥和私钥。望文生义，公钥就是任何感兴趣的一方都可以
自由获取的，而私钥是保密的。私钥用来对报文加密，公钥则用来验证。只有私钥的
拥有者可以加密报文，任何可以访问公钥的人都可以验证报文。相反地，公钥可以加密报文，只有私钥可以解密报文。\\

RSA算法的强大之处在于，两个大质数的乘积很难被因式分解。质数越大，密钥越强劲
。质数的长度和产生的密钥导致操作处理非常慢。其他的非对称加密算法都是差不多慢
，所以对于大块的数据传输不适用。因此，SSL/TLS使用非对称加密验证，事先商定对称加密密钥
传输大块数据。在这点上，非对称密钥的优点在于无需再通信之前商定密钥，而且某种
程度上也减轻了非对称加密tigat的慢速。 \\

\subsubsection{对称加密}

对称加密允许双方共享一个密钥来进行加密通信。之所以被成为对称加密，是因为加密
和解密用的是同一个密钥。常见的对称加密算法有DES,DES3和最近的AES。\\

因为加密和解密使用的是同一个密钥，所以双方以安全的方式共享这个密钥就非常重要
。如果第三方获得了密钥，就可以伪造加密报文，也可以解密已加密的报文。如果端点
双方都在同一个私有网络，比如和银行通信的ATM和POS机，这通常不是什么大问题，只
要密钥被事先放在设备里。如果对于更常见的临时通信，正如SSL/TLS提供的，相互
信任关系需要在运行中确定，因此用于对称加密的密钥是哟你非对称通信来获得。对称
加密算法倾向于使用比非对称加密更短的密钥，这通常可以提供相似程度的安全。这
导致再软件中加密算法非常快，这非常重要，因为现在大多数的SSL/TLS都是再软件中
实现的。


\subsubsection{分块}

对称加密算法是基于块的。也就是加密一定量的数据，然后解密。但是SSL/TLS提供基于
流的数据传输，通常数据的数量和加密算法使用的块不想匹配。再任何情况下，传输的
数据和使用的算法是独立的，所以需要分块，把数据分解为块，如果必要的话，填充
块。\\

一个简单的分块实现是仅仅把数据分解为块大小的块，如果必要则填充块，然后加密
得到的块。这种方法叫做{\CJKfamily{kai}{\textbf{电子密码本}（\textbf{ECB})}}模式。
它的最大的缺点就是如果两块文本是相同的，那么密文也将相同。这个信息对于试图
解密流的攻击者是非常有利的。\\

因此，SSL/TLS使用{\CJKfamily{kai}{\textbf{密码分组链接（\textbf{CBC}）}}}模式
。当传送数据流时，第一块文本在加密前和一个\textbf{{\slshape{初始向量}}{（IV）}}异或。再SSL/TLS中，初始向量(IV)再握手商定密钥时产生，并且每次连接都不一
。样。后一块文本和前一块密文再加密前异或。这样第一块后的每一块都依赖于前一块。
所以尽管流里的两块文本相同，密文也不同。\\

\subsubsection{报文验证码}

{\CJKfamily{kai}{\textbf{报文验证码}（\textbf{MAC}）}}保证报文在传送过程中没
有被修改和丢失。它可以被看作是包含密钥的报文摘要。在数据发送时构造，在数据
接收时验证。如果不知道输入文本和密钥，是不可能伪造摘要的，因此，攻击者需要知道密钥
才能为一个改变的报文重新构造一个有效的{\bf{MAC}}。为了防止再次攻击，SSL和TLS
在构造{\bf{MAC}}时包含了单调递增的数字。

\subsection{端点确认}

 在双方通信时，确认对方确实是声称的对方也是非常重要的。在SSL/TLS中，这是通过证书来达到的。
 在建立SSL/TLS连接过程中，一个使用端点证书签字的报文和证书一起发送。证书本身是由认证机构签发的，网络信任是建立在认证机构。\\

 SSL/TLS是客户端-服务器协议。这和高层的客户端-服务器协议比如HTTPS,
 POP3S和IMAPS很类似。这种情况下，典型地是客户端验证确认服务器。也就是，网络服务器
 或者邮件服务器拥有证书，而客户端没有。但是，SSL和TLS允许服务器对客户端进行
 确认，这可以用来控制服务访问。匿名密钥交换也是可以的，在这种情况下，服务器
 不会发送自己的证书。这对攻击这伪造的服务器没有任何安全保证。 \\

 为了验证证书的合法性，需要做多次检查。基本的检查包括证书没有过期，检查它的
 名称和主机名相同。证书也需要加密确认，以确保是由某个认证机构签发的。提供
 认证机构列表来检查是由软件负责的。以HTTPS为例，网页浏览器通常包含了认证机构
 的列表，也可以在安装后添加或删除。服务器使用自己签发的证书也是很常见的，在
 这种情况下，通常由访问该网站的个人来确认证书的合法性。比如，检查离线足迹。
尽管通常希望它是合法的。

\section{版本}

SSL的第一个发布版本是SSLv2,由Netscape发布。但是他有一些缺陷。

\begin{itemize}
 
\item{{\bf{MAC}}比较弱，依赖于{\bf{MD5}}}

\item{验证和加密使用相同的密钥。使得出口密码MAC非常弱}
 
\item{使用TCP关闭数据链接，这意味着如果伪造TCP FIN\footnote{原文为SYN}报文，可以导致截断攻击。}
 \item{在攻击中，无法手动对握手进行保护}
\end{itemize}

这写问题被SSLv3解决，SSLv3也是由Netscape发布的。随后被{\bf{IETF}}采用，并
标准化为TLSv1。SSLv2和TLSv1主要的区别在于：

\begin{itemize}
        \item{从主密钥提高密钥扩展，主密钥在握手期间通过数据交换计算得到。}
        \item{SSLv3基于{\bf{HMAC}}早期修改版。TLSv1使用{\bf{HMAC}}。}
        \item{实现必须支持{\bf{DH/DSS}}密钥交换和{\bf{3DES}}。}
\end{itemize}

\section{记录层}

记录层封装了即将传送到底层协议(通常是TCP/IP)的报文。每个记录可以包含$2^{14}$字节
的数据，为了满足这个大小限制可以对报文进行分片。一个记录也可以包含多条报文，
只要它们是同意类型。这通常发生在握手阶段，为了把多条报文放在同一个数据包里
传输，提高握手速度，一条记录通常包含多个报文。\\

\setlength{\unitlength}{1cm}
\begin{picture}(14,3)
        \put(0,0){\line(0,1){2}}
        \put(0,0){\line(1,0){12}}
        \put(0,2){\line(1,0){12}}
        \put(12,0){\line(0,1){2}}
        \put(2,0){\line(0,1){2}}
        \put(7,0){\line(0,1){2}}
        \put(0.2,1){\texttt{内容类型}}
        \put(4,1){\texttt{版本}}
        \put(9,1){\texttt{长度}}
        \put(5,-0.5){记录头}
\end{picture}
\\


\vspace{1cm}
记录从记录头开始，包含了协议版本号，数据长度（以字节为单位）和报文类型，包括
change cipher spec,警告(alert),握手（handshake)和应用程序数据(application
data)。\\

紧接着记录头的是报文数据。数据是用商定的压缩算法压缩过的。然后，由于TSL和SSL中，并没有明确规定使用何种压缩算法，通常这个操作被省略。\\

然后对压缩的数据计算{\bf{MAC}}，并附加到记录之后。{\bf{MAC}}的计算方法在下
一部分涉及。\\


\begin{picture}(14,3)
        \put(0,0){\line(0,1){2}}
        \put(0,0){\line(1,0){12}}
        \put(0,2){\line(1,0){12}}
        \put(12,0){\line(0,1){2}}
        \put(9,0){\line(0,1){2}}
        \put(4,1){填充字节}
        \put(10,1){填充长度}
        \put(5,-0.5){记录填充}
\end{picture}
\\

如果块密码对于连接生效，那么就会填充报文，使得报文大小是密码块大小的倍数。填充
字段包含填充数据和一个字节的填充长度。填充长度（一个字节）所在字段也被包含在
填充长度里。填充长度最大可以达到255字节，只要保证最终记录长度是密码块长度的倍数。\\

举个例子，如果记录为123字节，块长度为8字节，那么填充四字节后，记录，填充加上
填充长度本身就会有128字节，是块长度的整数倍。12,20，和252也是合法的填充长度
。允许填充一系列的填充值某种程度上使得记录长度模糊不清。\\

\begin{picture}(14,3)
        \put(0,0){\line(0,1){2}}
        \put(0,0){\line(1,0){10}}
        \put(0,2){\line(1,0){10}}
        \put(2,0){\line(0,1){2}}
        \put(4,0){\line(0,1){2}}
        \put(6,0){\line(0,1){2}}
        \put(8,0){\line(0,1){2}}
        \put(10,0){\line(0,1){2}}
        \put(1,1.5){4}
        \put(0.2,0.8){{\small{填充字节1}}}
        \put(3,1.5){4}
        \put(2.2,0.8){{\small{填充字节2}}}
        \put(5,1.5){4}
        \put(4.2,0.8){{\small{填充字节3}}}
        \put(7,1.5){4}
        \put(6.2,0.8){{\small{填充字节4}}}
        \put(9,1.5){4}
        \put(8.2,0.8){{\small{填充长度}}}
        \put(4,-0.5){记录填充}

\end{picture}
\\
\vspace{1cm}

如果密码为{\bf{NULL}},或者是流密码，那么填充就不是必须的。实际中，这通常发生
握手是构建在文本基础上，并且使用{\bf{RC4}}。\\


\subsection{报文验证码}

TLS使用的报文验证码（{\bf{MAC}}）是{\bf{HMAC}},SSLv3使用的是{\bf{HMAC}}的
早期草稿版，因此称作{\bf{SSL3-MAC}}。\\

{\bf{HMAC}}可用下面的等式表达:

\begin{displaymath}
        H(K \oplus {\tt{opad}},H(K \oplus {\tt{ipad}},{\tt{text}}))\\{}
 \end{displaymath}

 \begin{center}
         \begin{minipage}[t]{0.30\textwidth}
                 {\bf{其中}}：\\

        $\oplus$:\verb| |是连接\\
        text:\verb|     |是要加密的明文\\
        H:\verb|        |是哈希函数\\
        B:\verb|        |是以字节为单位的H长度\\
        K:\verb|        |最多B字节长的密钥\\
        ipad:   B个字节0x36\\
        opad:   B个字节0x5C\\
\end{minipage}
\end{center}




%\begin{center}
%\begin{table}[h!b!p!]
%        \caption{记录头}
%\begin{tabular}{|p{2cm}|p{5cm}|p{5cm}|}
%
%\hline 
%内容类型 & 版本 & 长度\\
%
%\hline
%\end{tabular}
%\end{table}
%
%\end{center}




%\section{Socket API}
%
%\lstset{language=C,
%        %bkackgroundcolor=\color{green},
%        numbers=left,
%        breaklines,
%        basicstyle=\ttfamily\small,
%        keywordstyle=\color{red}\ttfamily,
%        identifierstyle=\color{blue}\ttfamily,
%        stringstyle=\ttfamily,
%        commentstyle=\ttfamily,
%        caption=\lstname,
%        captionpos=b}
%
%\lstinputlisting[name=main.cpp,
% %       linerange={28-85},
% %       firstnumber=28,
%        stepnumber=2]{/home/wolf/public/notes/blogs/code/etip/simplec.c} 
%
\end{document}
